#!/usr/bin/env bash
#
# dotfield
#
# Nix flake shortcuts.
#
# Usage:
#   dotfield <subcommand> [<args>...]
#   dotfield build [<flake-output>]
#   dotfield switch [<flake-output>]
#   dotfield evolve [<flake-output>]
#   dotfield repl [<flake-output>]

set -e

DOTFIELD_DIR="$(git rev-parse --show-toplevel)"

# shellcheck source=../lib/utils.sh
. "${DOTFIELD_DIR}/lib/utils.sh"

#========================================
# Get an absolute path to a system flake output.
#
# Usage:
#   flake::output <name>
# Arguments:
#   Flake output name.
# Globals:
#   DOTFIELD_DIR
#========================================
function flake::output() {
  local output_name=$1
  printf "%s/#%s" "${DOTFIELD_DIR}" "${output_name}"
}

#========================================
# Output the current hostname, with fallback approaches.
#
# Usage:
#   host::name
# Globals:
#   DOTFIELD_HOSTNAME
#   HOSTNAME
#========================================
function host::name() {
  echo "${DOTFIELD_HOSTNAME:-${HOSTNAME:-$(hostname)}}"
}

#========================================
# Build a specified flake output.
#
# Usage:
#   host::build <name> [<args>...]
# Arguments:
#   Flake output name.
#   Args to pass to the build command.
#========================================
function host::build() {
  local output="$1"
  shift
  nix build --verbose "$(flake::output "${output}")" "$@"
}

#========================================
# Switch to a new generation.
#
# Usage:
#   host::switch <name> [<args>...]
# Arguments:
#   Flake output name.
#   Args to pass to the switch command.
# Globals:
#   DOTFIELD_DIR
#========================================
function host::switch() {
  local output="$1"

  shift

  "${DOTFIELD_DIR}/result/sw/bin/darwin-rebuild" switch --verbose --flake \
    "$(flake::output "${output}")" \
    "$@" ||
    {
      msg::error "Failed to switch to the new generation!"
    }
}

#========================================
# Whether a given string indicates a dark interface.
#
# Usage:
#   theme::is_dark <value>
# Arguments:
#   String to test
# Returns:
#   0 - Dark
#   1 - Light
#   2 - Invalid test value
#========================================
function theme::is_dark() {
  case "$1" in
    on | dark) return 0 ;;
    off | light) return 1 ;;
    *)
      msg::error "[theme::is_dark] Invalid option specified: ${1}"
      return 2
      ;;
  esac
}

#========================================
# Switch to a different system UI theme.
#
# Note: this function calls the main function recursively
# Usage:
#   theme::switch (light|dark|<theme-name>)
# Arguments:
#   Either "light", "dark", or a theme name.
#========================================
function theme::switch() {
  local name=$1
  if theme::is_dark "${name}"; then
    DOTFIELD_THEME="black-metal-khold"
  else
    DOTFIELD_THEME="grayscale-light"
  fi
  export DOTFIELD_THEME
  host::switch "$(host::name)" --impure
}

#========================================
# Open a new Nix REPL shell for a flake output.
#
# FIXME: assumes darwin
#
# Usage:
#   host::repl <output-name>
# Arguments:
#   Flake output name.
# Globals:
#   DOTFIELD_DIR
#========================================
function host::repl() {
  local output="$1"
  local conf
  conf="$(mktemp)"

  msg::subdomain "Loading flake from ${output}..."

  output="darwinConfigurations.${output}"

  cat >"${conf}" <<EOF
(builtins.getFlake (toString ${DOTFIELD_DIR})).${output}
EOF

  nix repl "${conf}"
}

#========================================
# Entry point.
#========================================
function main() {
  local subcommand="$1"
  local output

  shift

  output="$(host::name)"

  case "${subcommand}" in
    build)
      msg::domain "Evolution" "Building '${output}'"
      host::build "${output}" "$@"
      ;;

    switch)
      msg::domain "Evolution" "Switching to new generation"
      host::switch "${output}" "$@"
      ;;

    evolve)
      msg::domain "Evolution" "Building '${output}'"
      host::build "${output}"

      msg::domain "Evolution" "Switching to new generation"
      host::switch "${output}"
      ;;

    repl)
      msg::domain "Introspection" "Launching REPL shell for ${output}"
      host::repl "${output}"
      ;;

    theme)
      local theme="$1"
      msg::domain "Visualisation" "Changing color theme to '${theme}'"
      theme::switch "$@"
      ;;

    *)
      msg::error "[Error] Invalid subcommand ${subcommand}! Aborting."
      return 1
      ;;
  esac
}

main "$@"
