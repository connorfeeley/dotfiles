#!/usr/bin/env bash

set -e

readonly QUERENT="montchr"
readonly REPO_ID="montchr/dots"
readonly DOTFILES_ORIGIN="git@github.com:${REPO_ID}.git"
readonly DOTFILES_BRANCH="${CDOM_INIT_DOTFILES_BRANCH:-main}"
readonly DOTFILES_TARBALL_URL="https://github.com/${REPO_ID}/tarball/${DOTFILES_BRANCH}"
readonly DOTFILES_UTILS_BASE_URL="https://raw.githubusercontent.com/${REPO_ID}/${DOTFILES_BRANCH}/lib"

export DOTFIELD="${DOTFIELD:-${HOME}/.config}"

export BASE_DIR="$( cd "${BASH_SOURCE[0]%/*}" && pwd )"


#========================================
# Download file from a URL.
#
# Usage:
#   download <url> <dest-path>
# Arguments:
#   URL
#   Destination path
# Returns:
#   0 - Download succeeded.
#   1 - Download failed.
#========================================
function download {
  local url="$1"
  local output="$2"
  if command -v "curl" &>/dev/null; then
    curl -LsSo "$output" "$url" &>/dev/null
    return $?
  elif command -v "wget" &>/dev/null; then
    wget -qO "$output" "$url" &>/dev/null
    return $?
  fi
  return 1
}


#========================================
# Source a file, falling back to sourcing ephemerally from the remote.
#
# Usage:
#   source_ephemeral <relative-path>
# Arguments:
#   Relative path to file
# Returns:
#   0 - Sourcing succeeded.
#   1 - Sourcing failed.
#========================================
function source_ephemeral {
  local path="$1"
  local tmp_file=""
  local url=""

  if [[ -f "${path}" ]]; then
    # shellcheck disable=SC1090
    . "${path}" \
      && return \
      || return 1
  fi

  tmp_file="$(mktemp /tmp/XXXXXXXX)"
  url="${DOTFILES_UTILS_BASE_URL}/${path}.sh"

  download "${url}" "${tmp_file}" && {
    # shellcheck disable=SC1090
    . "${tmp_file}" \
      && rm -rf "${tmp_file}"
  } && return 0

  return 1
}


#========================================
# Verify whether the current OS version is supported by this script.
#
# Globals:
#   OS_NAME
#   OS_VERSION
# Outputs:
#   Feedback on error.
# Returns:
#   0 - Supported.
#   1 - Unsupported.
#========================================
function verify_os {
  declare -A Names Versions
  local supported_version

  Names=(
    [macos]="macOS"
    [ubuntu]="Ubuntu"
  )

  Versions=(
    [macos]="10.10"
    [ubuntu]="20.04"
  )

  OS_VERSION="$(world::get_OS_VERSION)"
  OS_NAME="$(world::get_OS_NAME)"
  supported_version="${Versions[$OS_NAME]}"

  if [[ -z "$supported_version" ]]; then
    echo "Sorry, your OS is not supported!"
    return 1
  fi

  if is_supported_version "${OS_VERSION}" "${supported_version}"
  then
    return 0
  else
    printf "Sorry, this script is intended only for %s %s+" \
      "${Names[$OS_NAME]}" \
      "${supported_version}"
    return 1
  fi
}


#========================================
# Verify whether this script is an executable file in the expected location.
#
# Globals:
#   XDG_CONFIG_HOME
# Returns:
#   0 - Bootstrap is an executable file.
#   1 - Otherwise.
#========================================
function is_bootstrapped {
  [[ -x "${XDG_CONFIG_HOME}/bootstrap" ]]
}


#========================================
# Entrypoint.
#========================================
function main () {
  # Ensure that the following actions are made relative to this file's path.
  cd "$(dirname "${BASH_SOURCE[0]}")" ||
    exit 1
    
  source_ephemeral "utils"
  
  msg::domain "System" "Verifying system state"
    
  if is_bootstrapped; then 
    msg::info "We arrive at a well-travelled outcropping, overlooking a familiar vista. Let's get a closer look…"
  else
    msg::info "This world is beautiful, but dark. Let's get our bearings and see what we can see in the land below…"
  fi
  
  source_ephemeral "world" \
    && world::info

  # Ensure the OS is supported and above the minimum version.
  verify_os || return 1

  if ! is_bootstrapped; then
    msg::hed "Cloning dotfiles into ${XDG_CONFIG_HOME}"
  fi  
  
  # One cannot simply lift oneself up by one's own bootstraps...
  repo::sync "${XDG_CONFIG_HOME}" "gh" "${REPO_ID}"

  cd "${XDG_CONFIG_HOME}" || {
    print_error "We seem to be lost in '$(pwd)'. Something went wrong!"
    msg::error "The world fades to black as we dematerialize…"
    return 1
  }

  if [[ "root" == $(whoami) ]]; then
    msg::warning "Running as root!"
  else
    ask_for_sudo
  fi
  
  msg::domain "Supporting" "Loading framework"

  # shellcheck source=./vendor/bash-oo-framework/lib/oo-bootstrap.sh
  . "${BASE_DIR}/vendor/bash-oo-framework/lib/oo-bootstrap.sh"
  
  import \
    util/exception \
    util/tryCatch \
    util/namedParameters
  
  import utils world domain
  
  msg::domain "Supporting" "Defining variables"

  ALL="true"
  ACTION=
  case $1 in
    install|upgrade|test)
      ACTION=$1
      shift
      ;;
    *)
      echo
      if [ -z "$1" ]; then
        ACTION=install
      else
        error "action '$1' is not supported"
        log "supported actions are: install, upgrade, test"
        exit 1
      fi
      ;;
  esac
  
  POSITIONAL=()
  while [[ $# -gt 0 ]]
  do
    if [[ "$1" != "" ]]; then
      if [[ "$1" = -* ]]; then
        key=$(echo "${1#-}" | tr '[:upper:]' '[:lower:]')
        declare -r "guard_ignore_$key=true"
      else
        key=$(echo "$1" | tr '[:upper:]' '[:lower:]')
        declare -r "guard_$key=true"
        ALL="false"
      fi
    fi
    shift
  done
  set -- "${POSITIONAL[@]}" # restore positional parameters
  
  # @TODO this might not be desirable
  # if [[ "$INTERACTIVE" = "" ]]; then
  #   INTERACTIVE=true
  # fi
  
  # - - - - - - - - - - - - - - - - - - - -
  # Lockfile
  # - - - - - - - - - - - - - - - - - - - -
  
  msg::domain "Supporting" "Handling lock file" && {
  
    LOCK_FILE=$XDG_CACHE_HOME/eru/eru.lock
    if [[ -f "$LOCK_FILE" ]]; then
      msg::error "
    Yet another world is being shaped by Eru
  
    One must either wait patiently or embrace the horrors of the unknown and
    manually delete the $LOCK_FILE"
      exit 1
    fi
    mkdir -p "$(dirname "$LOCK_FILE")"
    touch "$LOCK_FILE"
  
    function unlock() {
      rm -rf "$LOCK_FILE"
    }
  
    trap unlock INT TERM EXIT
  
  }

  
  msg::domain "Guardian" "Ensure directories exist" && {

    ensure_dir "${XDG_BIN_HOME}"
    ensure_dir "$DEVELOPER"

    ensure_dir "$HOME/org" && {
      ensure_dir "$HOME/org/gtd"
      ensure_dir "$HOME/org/mind"
      ensure_dir "$HOME/org/roam"
    }

  }


  guard::domain "Repo" "Sync repos from Repofiles" && {
    map_lines sync_repo "$target/Repofile" || true
    map_lines sync_repo "$XDG_CONFIG_CACHE/eru/Repofile" || true
  }


  guard::domain "Link" "Link all files as defined in Linkfiles" && {

    linkfile "$target/Linkfile"
    linkfile "$XDG_CONFIG_CACHE/eru/Linkfile"
    linkfile "$XDG_CONFIG_CACHE/eru/Linkfile.${KERNEL_NAME}"

    for f in "$target"/**/Linkfile; do
      linkfile "$f"
    done

    for f in "$target"/**/Linkfile."${KERNEL_NAME}"; do
      linkfile "$f"
    done

  }


  # guard::domain "Link" "Link all files from module bin directories" && {

  #   for f in "$target/*/bin/*"; do
  #     safe_link "$f" "${XDG_BIN_HOME}/$(basename "$f")"
  #   done

  # }

  
  # - - - - - - - - - - - - - - - - - - - -
  # OS-Specific
  # - - - - - - - - - - - - - - - - - - - -

  guard::ubuntu \
    && os/ubuntu/install

  guard::arch \
    && os/arch/install

  guard::macos && {

    guard::domain "OS" "Install Essentials" && {
      os/macos/install
    }

    guard::domain "OS" "Write all defaults" && {
      os/macos/configure
    }

  }

  # @TODO do this in os configure
  guard::install "Hostname" "Set the system hostname" && {
    if [[ -n "${CDOM_INIT_HOSTNAME}" ]]; then
      hostname="${CDOM_INIT_HOSTNAME}"
    else
      ask "Set the hostname: "
      hostname="$(get_answer)"
    fi

    # shellcheck disable=SC1090
    . "os/$(get_os)/configure" "${hostname:-CDOM}"
  }


  msg::domain "Git" "Create a local git config file" && {
    touch "$target/git/local.config"
  }


  guard::macos && {

    guard::domain "skhd" "Patch skhd application PATH" && {
      check skhd && {
        "$target/bin/patch_skhd_path"
      }
    }

    guard::domain "yabai" "Ensure scripting addition is installed" && {

      # reinstall the scripting addition
      sudo yabai --uninstall-sa
      sudo yabai --install-sa

      # load the scripting addition
      killall Dock || true

      sudo yabai --load-sa

    }

  }


  guard::arch && {

    guard::domain "xmonad" "Rebuild Xmonad configurations" && {

      msg::section "Install xmonad" && (
        cd "$XDG_CONFIG_HOME/xmonad"
        stack --allow-different-user install || {
          notify send -a "Eru" -t "Failed to compile xmonad" -u critical
        }
      )

      msg::section "Restart xmonad" && {
        if pgrep d12-xmonad; then
          msg::info "Found running instance of xmonad. Restarting..."
          d12-xmonad --restart
        else
          msg::info "No running instance of xmonad is found. Meh..."
        fi
      }

    }
  }
  
  print_hed "Bootstrapping complete!"
  
  guard::install && {
      
    if ! is_ci; then
      print_hed "Restart"
  
      ask_for_confirmation "Do you want to restart? You probably should."
      printf "\n"
  
      if user_confirmed; then
        sudo shutdown -r now &> /dev/null
      fi
    fi
      
  }

  msg::success "Everything is good here" \
    && return 0

}

main "$@"
