# -*- mode: sh; eval: (sh-set-shell "bash") -*-
# shellcheck shell=bash
# 
# 
#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#::   \\\
#:: ======>      DOTFIELD PROVISIONER        ○
#::   ///
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>
# 
# 
# Thanks:
#   - https://github.com/d12frosted/environment
#   - https://github.com/alrra/dotfiles
#   - https://github.com/jasonheecs/ubuntu-server-setup
# 

# shellcheck disable=2153
[[ -n "$ZSH_VERSION" ]] \
  && emulate -L bash

DOTFIELD_BRANCH="${GITHUB_HEAD_REF:-${GITHUB_REF:-${DOTFIELD_BRANCH:-feature/reshape}}}"
DOTFIELD_BRANCH="${DOTFIELD_BRANCH#refs/heads/}"
USE_HTTPS="${USE_HTTPS:-true}"

readonly QUERENT="montchr"
readonly REPO_ID="montchr/dots"
readonly DOTFIELD_RAW_BASE_URL="https://raw.githubusercontent.com/${REPO_ID}/${DOTFIELD_BRANCH}"
readonly DOTFIELD_LOCK_FILE="${XDG_CACHE_HOME:-${HOME}/.cache}/dotfield/dotfield.lock"

DOTFIELD="$HOME/.config"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${DOTFIELD}}"
if [[ -d "$XDG_CONFIG_HOME" ]]; then
  DOTFIELD="$XDG_CONFIG_HOME"
fi
GITHUB_WORKSPACE=""
if [[ -d "${GITHUB_WORKSPACE}" ]]; then
  DOTFIELD="$GITHUB_WORKSPACE"
fi

BASE_DIR="$( cd "${BASH_SOURCE[0]%/*}" && pwd )"

export \
  BASE_DIR \
  DOTFIELD \
  DOTFIELD_BRANCH \
  HOSTNAME \
  QUERENT \
  REPO_ID


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   HELPER FUNCTIONS
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


#========================================
# Download file from a URL.
#
# Usage:
#   download <url> <dest-path>
# Arguments:
#   URL
#   Destination path
# Returns:
#   0 - Download succeeded.
#   1 - Download failed.
#========================================
function download {
  local url="$1"
  local output="$2"
  if command -v "curl" &>/dev/null; then
    curl -LsSo "$output" "$url" &>/dev/null
    return $?
  elif command -v "wget" &>/dev/null; then
    wget -qO "$output" "$url" &>/dev/null
    return $?
  fi
  return 1
}


#========================================
# Source a Dotfield file, falling back to sourcing ephemerally from the remote.
#
# Usage:
#   source_ephemeral <relative-path> [local-base]
# Arguments:
#   Relative path to file
#   Local mirror base directory
# Returns:
#   0 - Sourcing succeeded.
#   1 - Sourcing failed.
#========================================
function source_ephemeral {
  local path="$1"
  local local_mirror="${2-}"
  local filename
  local tmp_file=""
  local src_file=""

  if [[ -f "${path}" ]]; then
    # shellcheck disable=1090
    . "${path}" \
      && return
  fi

  filename="$(basename "${path}")"
  tmp_file="$(mktemp "/tmp/${filename}.XXXX")"
  
  if [[ -n "${local_mirror}" ]]; then
    src_file="${local_mirror}/${path}"
    echo "$src_file -> ${tmp_file}"
    cp -f "${src_file}" "${tmp_file}"
  else
    src_file="${DOTFIELD_RAW_BASE_URL}/${path}"
    echo "$src_file -> ${tmp_file}"
    download "${src_file}" "${tmp_file}"
  fi

  # shellcheck disable=1090
  . "${tmp_file}"
}


#========================================
# Verify whether the current OS version is supported by this script.
#
# Globals:
#   OS_NAME
#   OS_VERSION
# Outputs:
#   Feedback on error.
# Returns:
#   0 - Supported.
#   1 - Unsupported.
#========================================
function verify_os {
  declare -A Names Versions
  local supported_version

  Names=(
    [macos]="macOS"
    [ubuntu]="Ubuntu"
  )

  Versions=(
    [macos]="10.10"
    [ubuntu]="20.04"
  )

  supported_version="${Versions[$OS_NAME]}"

  if [[ -z "$supported_version" ]]; then
    echo "Sorry, your OS is not supported!"
    return 1
  fi

  str::is_supported_version \
    "${OS_VERSION}" \
    "${supported_version}" \
      && return 0

  printf "Sorry, this script is intended only for %s %s+" \
    "${Names[$OS_NAME]}" \
    "${supported_version}"
  return 1
}


#========================================
# Verify whether this script is an executable file in the expected location.
#
# Globals:
#   XDG_CONFIG_HOME
# Returns:
#   0 - Bootstrap is an executable file.
#   1 - Otherwise.
#========================================
function is_bootstrapped {
  [[ -x "${XDG_CONFIG_HOME}/bootstrap" ]]
}


#========================================
# Create the bootstrap lockfile.
#
# Globals:
#   DOTFIELD_LOCK_FILE
#========================================
function lock::engage {
  msg::domain "Supporting" "Engaging lock"
  mkdir -p "$(dirname "${DOTFIELD_LOCK_FILE}")"
  touch "${DOTFIELD_LOCK_FILE}"
}


#========================================
# Check whether the lock is engaged.
#
# Globals:
#   DOTFIELD_LOCK_FILE
# Returns:
#   0 - If the lock is engaged i.e. the lockfile exists.
#   1 - If the lock is disengaged i.e. the lockfile is absent.
#========================================
function lock::is_engaged {
  ! [[ -f "${DOTFIELD_LOCK_FILE}" ]]
}


#========================================
# Delete the bootstrap lockfile.
#
# Globals:
#   DOTFIELD_LOCK_FILE
#========================================
function lock::disengage {
  if ! [[ -f "${DOTFIELD_LOCK_FILE}" ]]; then
    return 0
  fi
  msg::domain "Supporting" "Disengaging lock"
  rm -rf "${DOTFIELD_LOCK_FILE}"
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   INITIALIZATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


if is_bootstrapped
then 

# shellcheck source=./lib/utils.sh
. "${XDG_CONFIG_HOME}/lib/utils.sh"

msg::stream::story <<END
We arrive at a well-travelled outcropping,
overlooking a familiar vista.

Let's get a closer look…
END

else

source_ephemeral "lib/utils.sh" "${DOTFIELD_TEST_BASE:-}"
msg::stream::story <<END
This world is beautiful, but dark.

Let's get our bearings and see what we can see
in the land below…
END

fi


msg::domain "System" "Verifying system state"
world::info


# Ensure the OS is supported and above the minimum version.
# @TODO validation function doesn't work for older versions of bash and neither do associative arrays
# verify_os || return 1


msg::domain "System" "Syncing dotfield with ${XDG_CONFIG_HOME}"
msg::stream::story <<END
One cannot simply lift oneself up by one's own bootstraps...
END
repo::sync "${XDG_CONFIG_HOME}" "gh" "${REPO_ID}" "${DOTFIELD_BRANCH}" || exit 1


msg::domain "Travelling" "-> ${XDG_CONFIG_HOME}"
cd "${XDG_CONFIG_HOME}" || {
msg::stream::errors <<END
We seem to be lost in '$(pwd)'.
Something went wrong!

The world fades to black as we dematerialize…
END
exit 1
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   PREPARATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


msg::domain "Supporting" "Defining variables"

ALL="true"
ACTION=""
case $1 in
  install|upgrade|test)
    ACTION=$1
    shift
    ;;
  *)
    if [[ -z "$1" ]]; then
      ACTION=install
    else
      msg::error "action '$1' is not supported"
      msg::info "supported actions are: install, upgrade, test"
      exit 1
    fi
    ;;
esac

POSITIONAL=()
while [[ $# -gt 0 ]]
do
  if [[ -n "$1" ]]; then
    if [[ "$1" = -* ]]; then
      key=$(str::lower "${1#-}")
      declare -r "guard_ignore_${key}=true"
    else
      key=$(str::lower "$1")
      declare -r "guard_${key}=true"
      ALL="false"
    fi
  fi
  shift
done
set -- "${POSITIONAL[@]}" # restore positional parameters
export ALL
export ACTION


msg::domain "Supporting" "Checking for lockfile"

if lock::is_engaged
then

msg::stream::errors <<END
Yet another world is being shaped by Eru

One must either wait patiently
or embrace the horrors of the unknown
and manually delete the lockfile:

:: ${DOTFIELD_LOCK_FILE}
END

exit 1
fi

lock::engage
trap lock::disengage INT TERM EXIT


guard::install && {
msg::domain "Supporting" "Authorizing superuser" && {
  if [[ "root" == $(whoami) ]]; then
    msg::warning "Running as root!"
  else
    # Ask for the administrator password upfront.
    sudo -v &>/dev/null

    # Update existing `sudo` time stamp until this script has finished.
    #
    # https://gist.github.com/cowboy/3118588
    while true; do
      sudo -n true
      sleep 60
      kill -0 "$$" || exit
    done &>/dev/null &
  fi
}
}  


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   EXPECTATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


guard::macos && {
(! shell::is_modern) && {
  # shellcheck source=./os/macos/_pre_install.sh
  . "${XDG_CONFIG_HOME}/os/macos/_pre_install.sh"
}
}


guard::install && {
msg::domain "Hostname" "Set the system hostname" && {
  if [[ -n "${CDOM_INIT_HOSTNAME}" ]]; then
    HOSTNAME="${CDOM_INIT_HOSTNAME}"
  else
    msg::ask "Enter a name: "
    HOSTNAME="$(msg::get_answer)"
  fi
}
}


msg::domain "Guardian" "Ensure directories exist"
fs::ensure_dir "${XDG_BIN_HOME}"
fs::ensure_dir "$DEVELOPER"
fs::ensure_dir "$HOME/org"
fs::ensure_dir "$HOME/org/gtd"
fs::ensure_dir "$HOME/org/mind"
fs::ensure_dir "$HOME/org/roam"


guard::domain "Repo" "Sync repos from Repofiles" && {
  fs::map_lines repo::sync "${XDG_CONFIG_HOME}/Repofile" || true
  # @TODO file doesn't exist. what's this for?
  fs::map_lines repo::sync "${XDG_CACHE_HOME}/dotfield/Repofile" || true
}


guard::domain "Link" "Link all files as defined in Linkfiles" && {
  fs::linkfile "${DOTFIELD}/Linkfile"
  for f in "${DOTFIELD}"/**/Linkfile; do
    fs::linkfile "$f";
  done
  for f in "${DOTFIELD}"/**/Linkfile."${KERNEL_NAME}"; do
    fs::linkfile "$f"
  done
}

msg::domain "Shell" "Sourcing profile"
# shellcheck source=./shell/profile
. "${XDG_CONFIG_HOME}/shell/profile"


# guard::domain "Link" "Link all files from module bin directories" && {

#   for f in "${DOTFIELD}/*/bin/*"; do
#     link "$f" "${XDG_BIN_HOME}/$(basename "$f")"
#   done

# }


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   INSTALLATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


guard::arch && {
# shellcheck source=./os/arch/install
. "${XDG_CONFIG_HOME}/os/arch/install"
}

guard::ubuntu && {
# shellcheck source=./os/ubuntu/main
. "${XDG_CONFIG_HOME}/os/ubuntu/main"
}

guard::macos && {
# shellcheck source=./os/macos/main
. "${XDG_CONFIG_HOME}/os/macos/main"
}


guard::install && {
  msg::domain "Editor" "Installing Doom Emacs" && {
    git clone --depth 1 https://github.com/hlissner/doom-emacs ~/.emacs.d
    # TODO: the shell environment should reflect the user's login shell
    # environment, not the environment this script was run within. this might not
    # normally matter, but it could have a confusing effect if this was only run
    # during initial bootstrapping
    doom install
  }


  guard::domain "php" "Install Composer" && {
    # shellcheck source=./composer/install
    . "${XDG_CONFIG_HOME}/composer/install"
  }


  guard::domain "espanso" "Install Espanso" && {
    # shellcheck source=./espanso/install
    . "${XDG_CONFIG_HOME}/espanso/install"
  }


  guard::domain "firefox" "Install Tridactyl" && {
    # shellcheck source=./firefox/install_tridactyl
    . "${XDG_CONFIG_HOME}/firefox/install_tridactyl"      
  }    


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   CONFIGURATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


  guard::macos && {
    guard::domain "firefox" "Link user chrome directory into existing profiles" && {
      for d in "${HOME}/Library/Application Support/Firefox/Profiles"/*
      do
        fs::link "${XDG_CONFIG_HOME}/firefox/chrome" "${d}/chrome"
      done
    }
  }
}


guard::upgrade && {
  # @TODO run in login shell! see previous note
  guard::domain "emacs" "Upgrading Doom Emacs" && {
    doom upgrade
  }
}


guard::macos && {

  # guard::domain "skhd" "Patch skhd application PATH" && {
  #   shell::has skhd && {
  #     # @TODO update this?
  #     "${DOTFIELD}/bin/patch_skhd_path"
  #   }
  # }

  guard::domain "yabai" "Ensure scripting addition is installed" && {
    shell::has yabai && {
      # reinstall the scripting addition
      sudo yabai --uninstall-sa
      sudo yabai --install-sa

      # load the scripting addition
      killall Dock || true

      sudo yabai --load-sa
    }
  }

}


guard::arch && {

  guard::domain "xmonad" "Rebuild Xmonad configurations" && {

    msg::subdomain "Install xmonad" && (
      cd "$XDG_CONFIG_HOME/xmonad"
      stack --allow-different-user install || {
        notify send -a "Eru" -t "Failed to compile xmonad" -u critical
      }
    )

    msg::subdomain "Restart xmonad" && {
      if pgrep d12-xmonad; then
        msg::info "Found running instance of xmonad. Restarting..."
        d12-xmonad --restart
      else
        msg::info "No running instance of xmonad is found. Meh..."
      fi
    }

  }
}


#====\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===\\===\\\===>
#:
#:    ==>   REALIZATION
#:
#====///===//===///===//===///===//===///===//===///===//===///===//===///===>


msg::success "Bootstrapping complete!"

guard::install && {
  
  if ! shell::is_ci; then
    msg::warning "Restart!"
    msg::ask_for_confirmation "Restart?"

    if msg::is_confirmed; then
      sudo shutdown -r now &> /dev/null
    fi
  fi
  
}

msg::success "Everything is good here."

return