# -*- mode: sh; eval: (sh-set-shell "bash") -*-
# shellcheck shell=bash
# 
# the revealing landscape
#

# shellcheck disable=2153
[[ -n "$ZSH_VERSION" ]] \
  && emulate -L bash

DOTFIELD_BRANCH="${GITHUB_SHA:-feature/reshape}"

readonly QUERENT="montchr"
readonly REPO_ID="montchr/dots"
readonly DOTFILES_ORIGIN="git@github.com:${REPO_ID}.git"
readonly DOTFILES_BRANCH="${DOTFIELD_BRANCH:-main}"
readonly DOTFIELD_RAW_BASE_URL="https://raw.githubusercontent.com/${REPO_ID}/${DOTFILES_BRANCH}"

USE_HTTPS="${USE_HTTPS:-true}"

DOTFIELD="$HOME/.config"
XDG_CONFIG_HOME="${XDG_CONFIG_HOME:-${DOTFIELD}}"
if [[ -d "$XDG_CONFIG_HOME" ]]; then
  DOTFIELD="$XDG_CONFIG_HOME"
fi
GITHUB_WORKSPACE=""
if [[ -d "${GITHUB_WORKSPACE}" ]]; then
  DOTFIELD="$GITHUB_WORKSPACE"
fi

BASE_DIR="$( cd "${BASH_SOURCE[0]%/*}" && pwd )"

export \
  BASE_DIR \
  DOTFIELD \
  DOTFILES_BRANCH \
  DOTFILES_ORIGIN \
  HOSTNAME \
  QUERENT \
  REPO_ID

# https://docwhat.org/tracebacks-in-bash

trap _exit_trap EXIT
trap _err_trap ERR
_showed_traceback=f

function _exit_trap() {
  local _ec="$?"
  if [[ $_ec != 0 && ${_showed_traceback} != t ]]; then
    traceback 1
  fi
}

function _err_trap() {
  local _ec="$?"
  local _cmd="${BASH_COMMAND:-unknown}"
  traceback 1
  _showed_traceback=t
  echo "The command ${_cmd} exited with exit code ${_ec}." 1>&2
}

function traceback() {
  # Hide the traceback() call.
  local -i start=$((${1:-0} + 1))
  local -i end=${#BASH_SOURCE[@]}
  local -i i=0
  local -i j=0

  echo "Traceback (last called is first):" 1>&2
  for ((i = start; i < end; i++)); do
    j=$((i - 1))
    local function="${FUNCNAME[$i]}"
    local file="${BASH_SOURCE[$i]}"
    local line="${BASH_LINENO[$j]}"
    echo "     ${function}() in ${file}:${line}" 1>&2
  done
}


#========================================
# Download file from a URL.
#
# Usage:
#   download <url> <dest-path>
# Arguments:
#   URL
#   Destination path
# Returns:
#   0 - Download succeeded.
#   1 - Download failed.
#========================================
function download {
  local url="$1"
  local output="$2"
  if command -v "curl" &>/dev/null; then
    curl -LsSo "$output" "$url" &>/dev/null
    return $?
  elif command -v "wget" &>/dev/null; then
    wget -qO "$output" "$url" &>/dev/null
    return $?
  fi
  return 1
}


#========================================
# Source a Dotfield file, falling back to sourcing ephemerally from the remote.
#
# Usage:
#   source_ephemeral <relative-path> [local-base]
# Arguments:
#   Relative path to file
#   Local mirror base directory
# Returns:
#   0 - Sourcing succeeded.
#   1 - Sourcing failed.
#========================================
function source_ephemeral {
  local path="$1"
  local local_mirror="${2-}"
  local filename
  local tmp_file=""
  local src_file=""

  if [[ -f "${path}" ]]; then
    # shellcheck disable=1090
    . "${path}" \
      && return
  fi

  filename="$(basename "${path}")"
  tmp_file="$(mktemp "/tmp/${filename}.XXXX")"
  
  if [[ -n "${local_mirror}" ]]; then
    src_file="${local_mirror}/${path}"
    echo "$src_file -> ${tmp_file}"
    cp -f "${src_file}" "${tmp_file}"
  else
    src_file="${DOTFIELD_RAW_BASE_URL}/${path}"
    echo "$src_file -> ${tmp_file}"
    download "${src_file}" "${tmp_file}"
  fi

  # shellcheck disable=1090
  . "${tmp_file}"
}


#========================================
# Verify whether the current OS version is supported by this script.
#
# Globals:
#   OS_NAME
#   OS_VERSION
# Outputs:
#   Feedback on error.
# Returns:
#   0 - Supported.
#   1 - Unsupported.
#========================================
function verify_os {
  declare -A Names Versions
  local supported_version

  Names=(
    [macos]="macOS"
    [ubuntu]="Ubuntu"
  )

  Versions=(
    [macos]="10.10"
    [ubuntu]="20.04"
  )

  supported_version="${Versions[$OS_NAME]}"

  if [[ -z "$supported_version" ]]; then
    echo "Sorry, your OS is not supported!"
    return 1
  fi

  str::is_supported_version \
    "${OS_VERSION}" \
    "${supported_version}" \
      && return 0

  printf "Sorry, this script is intended only for %s %s+" \
    "${Names[$OS_NAME]}" \
    "${supported_version}"
  return 1
}


#========================================
# Verify whether this script is an executable file in the expected location.
#
# Globals:
#   XDG_CONFIG_HOME
# Returns:
#   0 - Bootstrap is an executable file.
#   1 - Otherwise.
#========================================
function is_bootstrapped {
  [[ -x "${XDG_CONFIG_HOME}/bootstrap" ]]
}


#========================================
# Entrypoint.
#========================================
function main () {
  source_ephemeral "lib/utils.sh" "${DOTFIELD_TEST_BASE:-}"
  
  msg::domain "System" "Verifying system state"
  world.info
    
  if is_bootstrapped
  then 

    msg::info "
${MSG__INDENT}| We arrive at a well-travelled outcropping,
${MSG__INDENT}| overlooking a familiar vista.
${MSG__INDENT}|
${MSG__INDENT}| Let's get a closer look…"

  else

    msg::info "
${MSG__INDENT}| This world is beautiful, but dark.
${MSG__INDENT}| Let's get our bearings and
${MSG__INDENT}| see what we can see
${MSG__INDENT}| in the land below…"

  fi

  # Ensure the OS is supported and above the minimum version.
  # @TODO validation function doesn't work for older versions of bash and neither do associative arrays
  # verify_os || return 1

  msg::domain "System" "Syncing dotfield with ${XDG_CONFIG_HOME}" && {

    msg::info "
${MSG__INDENT}| One cannot simply lift oneself up by one's own bootstraps..."  

    repo::sync "${XDG_CONFIG_HOME}" "gh" "${REPO_ID}" "${DOTFIELD_BRANCH}"

  }
 

  msg::domain "Travelling" "-> ${XDG_CONFIG_HOME}" && {

    cd "${XDG_CONFIG_HOME}" || {

      msg::error "
${MSG__INDENT}| We seem to be lost in '$(pwd)'.
${MSG__INDENT}| Something went wrong!
${MSG__INDENT}|
${MSG__INDENT}| ~ The world fades to black as we dematerialize… ~"

      return 1

    }

}


  msg::domain "Supporting" "Defining variables" && {

    ALL="true"
    ACTION=""
    case $1 in
      install|upgrade|test)
        ACTION=$1
        shift
        ;;
      *)
        if [[ -z "$1" ]]; then
          ACTION=install
        else
          msg::error "action '$1' is not supported"
          msg::info "supported actions are: install, upgrade, test"
          exit 1
        fi
        ;;
    esac
    
    POSITIONAL=()
    while [[ $# -gt 0 ]]
    do
      if [[ -n "$1" ]]; then
        if [[ "$1" = -* ]]; then
          key=$(str::lower "${1#-}")
          declare -r "guard_ignore_${key}=true"
        else
          key=$(str::lower "$1")
          declare -r "guard_${key}=true"
          ALL="false"
        fi
      fi
      shift
    done
    set -- "${POSITIONAL[@]}" # restore positional parameters
    export ALL
    export ACTION
    
    # @TODO this might not be desirable
    # if [[ "$INTERACTIVE" = "" ]]; then
    #   INTERACTIVE=true
    # fi

  }


  guard::install && {
    msg::domain "Supporting" "Authorizing superuser" && {
      if [[ "root" == $(whoami) ]]; then
        msg::warning "Running as root!"
      else
        shell::ask_for_sudo
      fi
    }
  }


  
  # - - - - - - - - - - - - - - - - - - - -
  # Lockfile
  # - - - - - - - - - - - - - - - - - - - -
  
  msg::domain "Supporting" "Handling lock file" && {
  
    LOCK_FILE=$XDG_CACHE_HOME/eru/eru.lock
    if [[ -f "$LOCK_FILE" ]]; then

      msg::error "
${MSG__INDENT}| Yet another world is being shaped by Eru
${MSG__INDENT}| 
${MSG__INDENT}| One must either wait patiently
${MSG__INDENT}| or embrace the horrors of the unknown
${MSG__INDENT}| and manually delete the $LOCK_FILE"

      exit 1
    fi
    mkdir -p "$(dirname "$LOCK_FILE")"
    touch "$LOCK_FILE"
  
    function unlock() {
      rm -rf "$LOCK_FILE"
    }
  
    trap unlock INT TERM EXIT
  
  }


  guard::macos && ! shell::is_modern && {
    # shellcheck source=./os/macos/_pre_install.sh
    . "${XDG_CONFIG_HOME}/os/macos/_pre_install.sh"
  }


  guard::install  && {
    msg::domain "Hostname" "Set the system hostname" && {
      if [[ -n "${CDOM_INIT_HOSTNAME}" ]]; then
        HOSTNAME="${CDOM_INIT_HOSTNAME}"
      else
        msg::ask "Enter a name: "
        HOSTNAME="$(msg::get_answer)"
      fi
    }
  }

  
  msg::domain "Guardian" "Ensure directories exist" && {

    fs::ensure_dir "${XDG_BIN_HOME}"
    fs::ensure_dir "$DEVELOPER"

    fs::ensure_dir "$HOME/org" && {
      fs::ensure_dir "$HOME/org/gtd"
      fs::ensure_dir "$HOME/org/mind"
      fs::ensure_dir "$HOME/org/roam"
    }

  }


  guard::domain "Repo" "Sync repos from Repofiles" && {
    fs::map_lines repo::sync "${DOTFIELD}/Repofile" || true
    fs::map_lines repo::sync "$XDG_CONFIG_CACHE/eru/Repofile" || true
  }


  guard::domain "Link" "Link all files as defined in Linkfiles" && {

    fs::linkfile "${DOTFIELD}/Linkfile"
    
    for f in "${DOTFIELD}"/**/Linkfile; do
      fs::linkfile "$f"
    done

    for f in "${DOTFIELD}"/**/Linkfile."${KERNEL_NAME}"; do
      fs::linkfile "$f"
    done

  }
  
  msg::domain "Shell" "Sourcing profile" && {
    . "${XDG_CONFIG_HOME}/shell/profile"
  }


  # guard::domain "Link" "Link all files from module bin directories" && {

  #   for f in "${DOTFIELD}/*/bin/*"; do
  #     link "$f" "${XDG_BIN_HOME}/$(basename "$f")"
  #   done

  # }

  
  guard::arch && {
    # shellcheck source=./os/arch/install
    . "${XDG_CONFIG_HOME}/os/arch/install"
  }

  guard::ubuntu && {
    # shellcheck source=./os/ubuntu/main
    . "${XDG_CONFIG_HOME}/os/ubuntu/main"
  }

  guard::macos && {
    # shellcheck source=./os/macos/main
    . "${XDG_CONFIG_HOME}/os/macos/main"
  }


  guard::macos && {

    guard::domain "skhd" "Patch skhd application PATH" && {
      shell::has skhd && {
        # @TODO update this?
        "${DOTFIELD}/bin/patch_skhd_path"
      }
    }

    guard::domain "yabai" "Ensure scripting addition is installed" && {
      shell::has yabai && {
        # reinstall the scripting addition
        sudo yabai --uninstall-sa
        sudo yabai --install-sa

        # load the scripting addition
        killall Dock || true

        sudo yabai --load-sa
      }
    }

  }


  guard::arch && {

    guard::domain "xmonad" "Rebuild Xmonad configurations" && {

      msg::subdomain "Install xmonad" && (
        cd "$XDG_CONFIG_HOME/xmonad"
        stack --allow-different-user install || {
          notify send -a "Eru" -t "Failed to compile xmonad" -u critical
        }
      )

      msg::subdomain "Restart xmonad" && {
        if pgrep d12-xmonad; then
          msg::info "Found running instance of xmonad. Restarting..."
          d12-xmonad --restart
        else
          msg::info "No running instance of xmonad is found. Meh..."
        fi
      }

    }
  }
  
  msg::success "Bootstrapping complete!"
  
  guard::install && {
      
    if ! shell::is_ci; then
      msg::warning "Restart!"
      msg::ask_for_confirmation "Restart?"

      if msg::is_confirmed; then
        sudo shutdown -r now &> /dev/null
      fi
    fi
      
  }

  msg::success "Everything is good here." \
    && return 0

}

main "$@"
