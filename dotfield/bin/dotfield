#!/usr/bin/env bash
#
# dotfield
#
# Usage:
#   dotfield <subcommand> [<args>...]
#   dotfield build [<flake-output>]
#   dotfield repl [<flake-output>]

set -e

DOTFIELD_DIR="$(git rev-parse --show-toplevel)"

# shellcheck source=../../utils.sh
. "${DOTFIELD_DIR}/utils.sh"

#========================================
# Build the flake and switch to the new derivation.
#
# Global:
#   DOTFIELD_DIR
# Arguments:
#   Flake output URI.
#========================================
function __nix::build() {
  local output="$1"

  msg::subdomain "Rebuilding..."
  nix build -v "${output}"

  msg::subdomain "Switching to new generation..."
  local rebuild="${DOTFIELD_DIR}/result/sw/bin/darwin-rebuild"

  [[ -e "${rebuild}" ]] && {
    "${rebuild}" switch -v --flake "${output}"
  }
}

#========================================
# Open a new Nix REPL shell for a flake output.
#
# Global:
#   DOTFIELD_DIR
# Arguments:
#   Flake output name. Defaults to the current hostname.
#========================================
function __nix::repl() {
  local output="$1"
  local conf
  conf="$(mktemp)"

  msg::subdomain "Loading flake from ${output}..."

  output="darwinConfigurations.$(str::lower "$output")"

  cat > "${conf}" << EOF
(builtins.getFlake (toString ${DOTFIELD_DIR})).${output}
EOF

  nix repl "${conf}"
}

#========================================
# Entry point.
#========================================
function main() {

  local SUBCOMMAND="$1"
  local FLAKE_OUTPUT

  FLAKE_OUTPUT="${2:-${HOSTNAME:-${HOST:-$(hostname)}}}"

  local flake_path="${DOTFIELD_DIR}/#${FLAKE_OUTPUT}"

  case $SUBCOMMAND in
    build)
      msg::domain "Evolution" "Rebuilding '${FLAKE_OUTPUT}'"
      __nix::build "${flake_path}"
      ;;

    repl)
      msg::domain "Introspection" "Launching REPL shell for ${FLAKE_OUTPUT}"
      # TODO: Add support for NixOS
      __nix::repl "${FLAKE_OUTPUT}"
      ;;

    *)
      msg::error "[Error] Invalid subcommand ${SUBCOMMAND}! Aborting."
      return 1
      ;;
  esac
}

main "$@"
